Esta página es una ayuda a los programadores que vienen del mundo "visual" (VB clásico versiones 5.0 y 6.0)

VB.NET es otro lenguaje, por lo que esta comparación no se adecua (buscar Python vs .Net)

== Diferencias entre Python y VB ==

 * Python es fuertemente tipado, VB no. En VB se puede hacer 1 +"2" = 3, en python hay que convertir explicitamente los tipos: 1 + int("2") = 3 (esto evita errores del tipo "1" + "1" + 2 que en VB da 13 en vez de 4 o "112"). Para los tipos similares (ej enteros y flotantes) no hace falta conversión (ni en Python ni en VB). Adicionalmente, en python se puede modificar el comportamiento de las operaciones aritmeticas y booleanas dependiendo del tipo del los objetos involucrados.
 * Python es tipado dinámicamente, VB depende de la declaración de la variable (en python todas las variables equivalen al tipo {{{Variant}}} de VB, o sea, pueden adquirir cualquier tipo de datos). En VB no se puede cambiar el tipo de la variable en tiempo de ejecución (no se puede asignar un flotante a un entero), en Python no existe esta restricción.
 * En Python no se puede utilizar variables indefinidas o sin inicializar, en VB si (mas allá de la instrucción {{{Option Explicit}}} que solo obliga a definir las variables, no a inicializarlas). En VB, a las variables sin inicializar se les asigna un valor implícito en el "aire" dependiendo del contexto, lo que permite usar variables inexistentes con valores indefinidos (una de las causas del célebre error "No coinciden los tipos"). 
 * En Python no es se define el tipo de la variable (ver tipado dinámico), solo basta con inicializar su valor (o None si no lo tiene). En VB es necesario hacer dos pasos, definir el tipo e inicializar la variable (salvo que el valor inicial sea el predeterminado que se le asigna implicitamente según el tipo, ej. enteros = 0). En general, se define el tipo para inicializarla con el valor predeterminado (para evitar el problema del punto anterior), perdiendo el dinamismo del lenguaje.
 * Python es sensible a maúsculas y minúsculas, VB no (para bien o para mal...). Igualmente, VB "corrige" mayúsculas y minúsculas a medida que se escribe (esto es útil para ver si está definida la variable o no, pero tambien trae problemas si se redefinia la variable en otro contexto, cambia el nombre en el resto de los módulos). En Python, hay que escribir bien desde el principio el nombre de la variable.
 * Python no distingue entre manejo por referencia y por valor, pero si entre tipos mutables e inmutables. Los tipos mutables (listas, diccionarios y objetos del usuario) se utilizan siempre por "referencia". Los tipos inmutables (enteros, flotantes, cadenas) se utilizan siempre por "valor". 
 * En Python, los tipos mutables (por "referencia") se asignan de la misma manera que los tipos inmutables (por "valor"). No hay una distinción explícita como en VB donde es necesario utilizar la instrucción {{{Set variable = valor}}}, ni en los argumentos con los modificadores {{{ByValue}}} y {{{ByRef}}}.
 * En Python hay un solo tipo de objeto nulo: {{{None}}}. En VB existe {{{Nothing}}} para objetos por referencia (mutables), {{{Null}}} para valores nulos (dentro de variables sin tipo), {{{Empty}}} para variables no definidas (no son posibles en Python), {{{Missing}}} para parámetros opcionales no pasados a la función. En Python cualquier variable puede se nula, en VB solo las variables sin tipo (causa del célebre error "Uso de null no válido").
 * En Python todos los parámetros son por nombre independientemente de su posición y si son o no optativos. En VB se pueden pasar parámetros por nombre pero solo en su posición y si son optativos (tienen definido un valor por defecto). Tanto en Python como en VB los parámetros por nombre se pueden usar por posición.
 * Si bien ambos son lenguajes multiparadigma, en python se puede programar funcionalmente además del modo  procedural y orientado a objetos, con muy buenas herramientas de introspección y metaprogramación.
 * Python soporta herencia (múltiple), constructores con parámetros, metodos de clase y estáticos, por lo que es un lenguaje más amigable desde el punto de vista de Orientación a Objetos. Las variables y métodos privados en python son semi-publicos, y python no soporta interfaces (aunque se pueden emular). Ambos soportan metodos y variables de instancia y propiedades. 
 * Python no soporta atributos/propiedades por defecto. En VB, si no se especifica atributo, en general hay uno por defecto. Ej. {{{col('hola')}}} en una colección en realidad esta accediendo al método Item: {{{col.Item('hola')}}}. Esto es similar a la sintaxis de Python para los diccionarios: {{{dic['hola']}}} es similar a {{{dic.__getitem__('hola')}}}, pero en VB tiene un uso implicito mucho mas extendido.
 * Python no soporta variables estáticas (variables definidas dentro del contexto de una función, cuyo valor perdura entre los distintos llamados), pero si soporta generadores (donde se puede ir devolviendo resultado sin salir de la funcion, preservando los valores de las variables locales).
 * VB soporta colecciones similares a los diccionarios de Python. En comparación, los diccionarios son más poderosos, tienen un método para ver si una clave esta definida (en VB la única forma de saberlo es tratar de obtener dicha clave y ver si se producía un error), se pueden recorrer sus claves (en VB solo es posible recorrer sus valores: {{{For Each val in coleccion}}}). En VB se pueden usar colecciones sin clave, que serían el equivalente a las Listas de Python. En VB, las claves deben ser cadenas, ya que si se utiliza números enteros se accede por posición. En Python no se puede acceder directamente por posición en los diccionarios (habría que obtener una lista de los valores) y las claves pueden ser cualquier valor inmutable (cadenas, enteros, etc.)
 * Python no soporta arreglos o vectores. En VB los vectores o arreglos son el equivalente a listas de longitud fija o variable de Python, los cuales pueden ser redimensionados (preservando sus valor o no, {{{Redim Preserve arreglo()}}}. Los arreglos de VB solo se pueden recorrer por posición (en Python por posición {{{lista[pos]}}} y por comprension {{{for elem in lista}}}) y no se puede "recortar" facilmente un subconjunto de elementos (en Python: {{{lista[pos_inicial:pos_final]}}}).

To be continued...
